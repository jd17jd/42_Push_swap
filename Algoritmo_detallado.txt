ALGORITMO:
    1. Declaracion a nuestras dos estructuras de datos / listas enlazadas. Una para A y otra para B.
        Inicializar ambas pilas a NULL para evitar comportamiento indefinido.

    2. Control de errores entrada.
        - Debe haber dos o mas argumentos

    3. Parseo de la entrada
        - Válido
            - Si es un único argumento en forma de string
                - ./ejeuctable "1 2 3 4 5"
                    --> [[1], [2], [3], [4], [5]]
                        --> algoritmo a elementos

            - Si tiene un numero variable de argumentos
                - ./ejeuctable 1
                    --> [[1]]
                        --> algoritmo al elemento

                - ./ejeuctable 1 2 3 4 5
                    --> algoritmo a los argumentos

        - No válido
            - Si no son numeros
                - ./ejecutable hola como esta
                - ./ejecutable 1 2 hola

            - Si tiene numeros duplicados
                - ./ejecutable "1 1"
                - ./ejecutable 1 2 3 4 4

            - Si tiene numeros mayores a MAXINT
                - ./ejecutable "9999999999"
                - ./ejecutable 9999999999 999999999


    [[1], [2], [3], [4], [5]]

        ALGORITMO:
        - Comprobar que:
            - sea un numero
            - no sea superior a MAXINT
            ft_atoi
        - El numero no esté duplicado
            ft_isdup




    4. Inicializar StackA apilando cada numero de entrada como un nodo de StackA
        Manejar los erroes de los posibles nodos a apilar (overflow, duplicados, elementos que no sean long int)
        Los nodos deben ser long int
        Apilar los nodos a StackA

    5. Comprobar si StackA está ordenado
        Si no está ordenado implementar nuestro algoritmo
        Comprobar 2 numeros. Si no estan ordedos. Rotarlos
        Comprobar 3 numeros. Si no están ordenados, implementar nuestro simple algoritmo "ordenar arbol"
        Si tiene más de 3 números, implementar nuestro "algoritmo turco"

    6. Limpiar stack